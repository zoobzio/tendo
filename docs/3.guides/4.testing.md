---
title: Testing
description: Testing tensor operations with tendo/testing utilities
author: zoobzio
published: 2025-12-16
updated: 2025-12-16
tags:
  - Testing
  - Assertions
  - Utilities
---

# Testing

The `tendo/testing` package provides utilities for testing tensor operations.

## Installation

```go
import (
    "testing"

    "github.com/zoobzio/tendo"
    tendotest "github.com/zoobzio/tendo/testing"
)
```

## Assertions

### AssertTensorEqual

Compare two tensors for approximate equality:

```go
func TestAdd(t *testing.T) {
    ctx := context.Background()
    a := tendo.FromSlice([]float32{1, 2, 3}, 3)
    b := tendo.FromSlice([]float32{4, 5, 6}, 3)

    result, err := tendo.Add(b).Run(ctx, a)
    if err != nil {
        t.Fatal(err)
    }
    expected := tendo.FromSlice([]float32{5, 7, 9}, 3)

    tendotest.AssertTensorEqual(t, expected, result, tendotest.DefaultTolerance)
}
```

Checks:
- Same shape
- Same number of elements
- Values within tolerance

### AssertTensorShape

Verify tensor shape:

```go
func TestReshape(t *testing.T) {
    ctx := context.Background()
    a := tendo.Zeros(12)
    b, err := tendo.Reshape(3, 4).Run(ctx, a)
    if err != nil {
        t.Fatal(err)
    }

    tendotest.AssertTensorShape(t, b, 3, 4)
}
```

### AssertTensorValues

Check tensor contains expected values:

```go
func TestFromSlice(t *testing.T) {
    data := []float32{1, 2, 3, 4}
    tensor := tendo.FromSlice(data, 2, 2)

    tendotest.AssertTensorValues(t, tensor, data, tendotest.DefaultTolerance)
}
```

### AssertScalar

Check scalar tensor value:

```go
func TestSum(t *testing.T) {
    ctx := context.Background()
    a := tendo.FromSlice([]float32{1, 2, 3, 4}, 4)
    sum, err := tendo.Sum().Run(ctx, a)  // Reduce all dimensions
    if err != nil {
        t.Fatal(err)
    }

    tendotest.AssertScalar(t, sum, 10.0, tendotest.DefaultTolerance)
}
```

## Tolerance

### Default Tolerance

```go
const DefaultTolerance = 1e-6
```

Suitable for most Float32 operations.

### Custom Tolerance

Use larger tolerance for:
- Accumulated operations
- Reduced precision types
- Operations with numerical approximations

```go
// More lenient for complex operations
tendotest.AssertTensorEqual(t, expected, result, 1e-4)

// Very strict for simple operations
tendotest.AssertTensorEqual(t, expected, result, 1e-8)
```

### Approximate Comparison

```go
// Single values
tendotest.ApproxEqual(3.14159, 3.14160, 1e-4)  // true

// Relative tolerance
tendotest.ApproxEqualRel(100.0, 100.01, 0.001)  // true (0.1% difference)
```

## Test Data Generation

### Sequential Data

```go
// 1D sequential
seq := tendotest.Range(10)  // [0, 1, 2, ..., 9]

// Shaped sequential
shaped := tendotest.RangeWithShape(3, 4)  // [[0,1,2,3], [4,5,6,7], [8,9,10,11]]
```

### Constant Fill

```go
ones := tendotest.Constant(1.0, 3, 4)
zeros := tendotest.Constant(0.0, 2, 2)
pi := tendotest.Constant(3.14159, 5)
```

### MustTensor

Create tensor that panics on error:

```go
func TestOperation(t *testing.T) {
    // Panics if shape doesn't match data length
    input := tendotest.MustTensor([]float32{1, 2, 3, 4}, 2, 2)

    // Use in test...
}
```

## Utility Functions

### TensorData

Extract tensor data as flat slice:

```go
tensor := tendo.FromSlice([]float32{1, 2, 3, 4}, 2, 2)
data := tendotest.TensorData(tensor)
// []float32{1, 2, 3, 4}
```

Handles non-contiguous tensors:

```go
ctx := context.Background()
transposed, _ := tendo.Transpose(0, 1).Run(ctx, tensor)
data := tendotest.TensorData(transposed)
// Returns contiguous copy: []float32{1, 3, 2, 4}
```

### ShapesEqual

Compare shapes:

```go
a := []int{3, 4, 5}
b := []int{3, 4, 5}
c := []int{3, 4}

tendotest.ShapesEqual(a, b)  // true
tendotest.ShapesEqual(a, c)  // false
```

### AllClose

Check if all elements are within tolerance:

```go
a := tendo.FromSlice([]float32{1.0, 2.0, 3.0}, 3)
b := tendo.FromSlice([]float32{1.0, 2.0, 3.0001}, 3)

tendotest.AllClose(a, b, 1e-3)  // true
tendotest.AllClose(a, b, 1e-5)  // false
```

### MaxAbsDiff

Find maximum difference between tensors:

```go
a := tendo.FromSlice([]float32{1.0, 2.0, 3.0}, 3)
b := tendo.FromSlice([]float32{1.1, 2.0, 3.2}, 3)

diff := tendotest.MaxAbsDiff(a, b)  // 0.2
```

### PrintTensor

Debug output:

```go
tensor := tendo.FromSlice([]float32{1, 2, 3, 4}, 2, 2)
tendotest.PrintTensor(tensor, "myTensor")
// Output: myTensor: shape=[2 2], data=[1 2 3 4]
```

## Test Patterns

### Table-Driven Tests

```go
func TestActivations(t *testing.T) {
    tests := []struct {
        name     string
        op       pipz.Chainable[*tendo.Tensor]
        input    []float32
        expected []float32
    }{
        {
            name:     "ReLU positive",
            op:       tendo.ReLU(),
            input:    []float32{1, 2, 3},
            expected: []float32{1, 2, 3},
        },
        {
            name:     "ReLU negative",
            op:       tendo.ReLU(),
            input:    []float32{-1, -2, -3},
            expected: []float32{0, 0, 0},
        },
        {
            name:     "ReLU mixed",
            op:       tendo.ReLU(),
            input:    []float32{-1, 0, 1},
            expected: []float32{0, 0, 1},
        },
    }

    ctx := context.Background()
    for _, tc := range tests {
        t.Run(tc.name, func(t *testing.T) {
            input := tendo.FromSlice(tc.input, len(tc.input))
            result, err := tc.op.Run(ctx, input)
            if err != nil {
                t.Fatal(err)
            }
            tendotest.AssertTensorValues(t, result, tc.expected, tendotest.DefaultTolerance)
        })
    }
}
```

### Shape Testing

```go
func TestBroadcasting(t *testing.T) {
    tests := []struct {
        shapeA   []int
        shapeB   []int
        expected []int
    }{
        {[]int{3, 4}, []int{4}, []int{3, 4}},
        {[]int{3, 4}, []int{3, 1}, []int{3, 4}},
        {[]int{1, 4}, []int{3, 1}, []int{3, 4}},
    }

    ctx := context.Background()
    for _, tc := range tests {
        t.Run(fmt.Sprintf("%v+%v", tc.shapeA, tc.shapeB), func(t *testing.T) {
            a := tendo.Zeros(tc.shapeA...)
            b := tendo.Zeros(tc.shapeB...)
            result, err := tendo.Add(b).Run(ctx, a)
            if err != nil {
                t.Fatal(err)
            }

            tendotest.AssertTensorShape(t, result, tc.expected...)
        })
    }
}
```

### Error Testing

```go
func TestShapeError(t *testing.T) {
    ctx := context.Background()
    a := tendo.Zeros(3, 4)
    b := tendo.Zeros(5, 6)

    _, err := tendo.MatMul(b).Run(ctx, a)
    if err == nil {
        t.Error("expected error for incompatible shapes")
    }

    var shapeErr *tendo.ShapeError
    if !errors.As(err, &shapeErr) {
        t.Errorf("expected ShapeError, got %T", err)
    }
}
```

### Device Testing

```go
func TestCUDAIfAvailable(t *testing.T) {
    if !tendo.IsCUDAAvailable() {
        t.Skip("CUDA not available")
    }

    ctx := context.Background()
    gpu := tendo.CUDADevice(0)
    a := tendo.ZerosOn(gpu, 100, 100)
    b := tendo.ZerosOn(gpu, 100, 100)

    result, err := tendo.Add(b).Run(ctx, a)
    if err != nil {
        t.Fatal(err)
    }

    if !result.Device().IsCUDA() {
        t.Error("expected result on CUDA device")
    }
}
```

### Numerical Stability

```go
func TestSoftmaxStability(t *testing.T) {
    ctx := context.Background()

    // Test with large values that could cause overflow
    large := tendotest.Constant(100.0, 10)
    result, err := tendo.Softmax(-1).Run(ctx, large)
    if err != nil {
        t.Fatal(err)
    }

    // Should sum to 1
    sum, err := tendo.Sum().Run(ctx, result)
    if err != nil {
        t.Fatal(err)
    }
    tendotest.AssertScalar(t, sum, 1.0, 1e-5)

    // No NaN or Inf
    data := tendotest.TensorData(result)
    for i, v := range data {
        if math.IsNaN(float64(v)) || math.IsInf(float64(v), 0) {
            t.Errorf("invalid value at index %d: %v", i, v)
        }
    }
}
```

## Benchmarking

```go
func BenchmarkMatMul(b *testing.B) {
    ctx := context.Background()
    sizes := []int{64, 128, 256, 512}

    for _, size := range sizes {
        b.Run(fmt.Sprintf("%dx%d", size, size), func(b *testing.B) {
            a := tendo.RandN(size, size)
            c := tendo.RandN(size, size)

            b.ResetTimer()
            for i := 0; i < b.N; i++ {
                _, _ = tendo.MatMul(c).Run(ctx, a)
            }
        })
    }
}
```

### CUDA Benchmarks

```go
func BenchmarkMatMulCUDA(b *testing.B) {
    if !tendo.IsCUDAAvailable() {
        b.Skip("CUDA not available")
    }

    ctx := context.Background()
    gpu := tendo.CUDADevice(0)
    a := tendo.RandNOn(gpu, 1024, 1024)
    c := tendo.RandNOn(gpu, 1024, 1024)

    // Warmup
    _, _ = tendo.MatMul(c).Run(ctx, a)

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        result, _ := tendo.MatMul(c).Run(ctx, a)
        // Sync to ensure operation completes
        _, _ = tendo.Sync().Run(ctx, result)
    }
}
```
