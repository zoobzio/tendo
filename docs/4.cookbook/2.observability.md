---
title: Observability
description: Monitoring tensor operations with capitan signals
author: zoobzio
published: 2025-12-16
updated: 2025-12-16
tags:
  - Observability
  - Signals
  - capitan
  - Logging
---

# Observability

Tendo emits [capitan](https://github.com/zoobzio/capitan) signals for all operations, enabling logging, profiling, and autograd integration.

## Signal Categories

### Lifecycle Signals

```go
tendo.TensorCreated   // Tensor allocated
tendo.TensorFreed     // Tensor deallocated
tendo.TensorTransfer  // Tensor moved between devices
```

### Operation Signals

```go
// Element-wise
tendo.OpAdd, tendo.OpSub, tendo.OpMul, tendo.OpDiv
tendo.OpNeg, tendo.OpAbs, tendo.OpExp, tendo.OpLog
tendo.OpSqrt, tendo.OpSquare, tendo.OpPow

// Matrix
tendo.OpMatMul, tendo.OpTranspose

// Shape
tendo.OpReshape, tendo.OpSqueeze, tendo.OpUnsqueeze
tendo.OpSlice, tendo.OpExpand, tendo.OpCat, tendo.OpStack

// Reduction
tendo.OpSum, tendo.OpMean, tendo.OpMax, tendo.OpMin
tendo.OpArgMax, tendo.OpArgMin

// Activation
tendo.OpReLU, tendo.OpSigmoid, tendo.OpTanh, tendo.OpGELU
tendo.OpSoftmax, tendo.OpLogSoftmax, tendo.OpDropout
```

### Memory Signals

```go
tendo.PoolAlloc  // Memory allocated from pool
tendo.PoolFree   // Memory returned to pool
```

## Field Keys

Extract typed data from events:

```go
// Tensor fields
tendo.KeyInput     // *Tensor - unary input
tendo.KeyInputA    // *Tensor - binary input A
tendo.KeyInputB    // *Tensor - binary input B
tendo.KeyInputs    // []*Tensor - n-ary inputs
tendo.KeyOutput    // *Tensor - operation output

// Metadata fields
tendo.KeyShape     // []int - tensor shape
tendo.KeyDevice    // Device - tensor device
tendo.KeyFromDevice // Device - transfer source
tendo.KeyToDevice   // Device - transfer destination
tendo.KeyDim       // int - dimension index
tendo.KeyDims      // []int - multiple dimensions
tendo.KeyBytes     // int - byte count
tendo.KeyScalar    // float32 - scalar value
tendo.KeyOpName    // string - operation name
```

## Basic Logging

### Log All Operations

```go
import "github.com/zoobzio/capitan"

capitan.Observe(func(ctx context.Context, e *capitan.Event) {
    // Log signal name
    log.Printf("[%s] %s", e.Signal().Name(), e.Signal().Description())
})
```

### Log Specific Operations

```go
// Log only matrix operations
capitan.Hook(tendo.OpMatMul, func(ctx context.Context, e *capitan.Event) {
    inputA, _ := tendo.KeyInputA.From(e)
    inputB, _ := tendo.KeyInputB.From(e)
    output, _ := tendo.KeyOutput.From(e)

    log.Printf("MatMul: %v @ %v -> %v",
        inputA.Shape(), inputB.Shape(), output.Shape())
})
```

### Filter by Signal Pattern

```go
// Log all tendo operations
capitan.Observe(func(ctx context.Context, e *capitan.Event) {
    if strings.HasPrefix(e.Signal().Name(), "tendo.op.") {
        log.Printf("Op: %s", e.Signal().Name())
    }
})
```

## Profiling

### Operation Timing

```go
type OpProfile struct {
    mu       sync.Mutex
    counts   map[string]int64
    durations map[string]time.Duration
}

func NewOpProfiler() *OpProfile {
    return &OpProfile{
        counts:    make(map[string]int64),
        durations: make(map[string]time.Duration),
    }
}

func (p *OpProfile) Start() {
    capitan.Observe(func(ctx context.Context, e *capitan.Event) {
        name := e.Signal().Name()
        if !strings.HasPrefix(name, "tendo.op.") {
            return
        }

        p.mu.Lock()
        p.counts[name]++
        p.mu.Unlock()
    })
}

func (p *OpProfile) Report() {
    p.mu.Lock()
    defer p.mu.Unlock()

    fmt.Println("Operation counts:")
    for op, count := range p.counts {
        fmt.Printf("  %s: %d\n", op, count)
    }
}
```

### Memory Tracking

```go
type MemoryTracker struct {
    mu        sync.Mutex
    allocated int64
    freed     int64
    peak      int64
    current   int64
}

func (m *MemoryTracker) Start() {
    capitan.Hook(tendo.PoolAlloc, func(ctx context.Context, e *capitan.Event) {
        bytes, _ := tendo.KeyBytes.From(e)
        m.mu.Lock()
        m.allocated += int64(bytes)
        m.current += int64(bytes)
        if m.current > m.peak {
            m.peak = m.current
        }
        m.mu.Unlock()
    })

    capitan.Hook(tendo.PoolFree, func(ctx context.Context, e *capitan.Event) {
        bytes, _ := tendo.KeyBytes.From(e)
        m.mu.Lock()
        m.freed += int64(bytes)
        m.current -= int64(bytes)
        m.mu.Unlock()
    })
}

func (m *MemoryTracker) Report() {
    m.mu.Lock()
    defer m.mu.Unlock()

    fmt.Printf("Memory: allocated=%d, freed=%d, peak=%d, current=%d\n",
        m.allocated, m.freed, m.peak, m.current)
}
```

## Computation Graph Capture

### Recording Operations

```go
type GraphRecorder struct {
    mu     sync.Mutex
    events []*capitan.Event
}

func (r *GraphRecorder) Start() *capitan.Observer {
    return capitan.Observe(func(ctx context.Context, e *capitan.Event) {
        if !strings.HasPrefix(e.Signal().Name(), "tendo.op.") {
            return
        }

        r.mu.Lock()
        // Clone event to keep reference after callback
        r.events = append(r.events, e.Clone())
        r.mu.Unlock()
    })
}

func (r *GraphRecorder) Events() []*capitan.Event {
    r.mu.Lock()
    defer r.mu.Unlock()

    result := make([]*capitan.Event, len(r.events))
    copy(result, r.events)
    return result
}

func (r *GraphRecorder) Clear() {
    r.mu.Lock()
    r.events = nil
    r.mu.Unlock()
}
```

### Usage

```go
recorder := &GraphRecorder{}
observer := recorder.Start()

// Run forward pass
output := model.Forward(input)

// Stop recording
observer.Close()

// Analyze recorded operations
for _, e := range recorder.Events() {
    output, _ := tendo.KeyOutput.From(e)
    fmt.Printf("%s -> shape %v\n", e.Signal().Name(), output.Shape())
}
```

## Autograd Foundation

Signals provide the foundation for autograd:

```go
type Tape struct {
    operations []Operation
}

type Operation struct {
    signal capitan.Signal
    inputs []*tendo.Tensor
    output *tendo.Tensor
}

func (t *Tape) Record() *capitan.Observer {
    return capitan.Observe(func(ctx context.Context, e *capitan.Event) {
        if !strings.HasPrefix(e.Signal().Name(), "tendo.op.") {
            return
        }

        op := Operation{signal: e.Signal()}

        // Capture inputs
        if input, ok := tendo.KeyInput.From(e); ok {
            op.inputs = []*tendo.Tensor{input}
        }
        if inputA, ok := tendo.KeyInputA.From(e); ok {
            op.inputs = append(op.inputs, inputA)
        }
        if inputB, ok := tendo.KeyInputB.From(e); ok {
            op.inputs = append(op.inputs, inputB)
        }

        // Capture output
        if output, ok := tendo.KeyOutput.From(e); ok {
            op.output = output
        }

        t.operations = append(t.operations, op)
    })
}

func (t *Tape) Backward(grad *tendo.Tensor) {
    // Walk tape backwards computing gradients
    for i := len(t.operations) - 1; i >= 0; i-- {
        op := t.operations[i]

        switch op.signal {
        case tendo.OpAdd:
            // grad_a = grad, grad_b = grad
        case tendo.OpMatMul:
            // grad_a = grad @ b.T, grad_b = a.T @ grad
        case tendo.OpReLU:
            // grad_in = grad * (input > 0)
        // ... more operations
        }
    }
}
```

## Integration Examples

### Structured Logging

```go
import "log/slog"

func setupLogging() {
    handler := slog.NewJSONHandler(os.Stdout, nil)
    logger := slog.New(handler)

    capitan.Observe(func(ctx context.Context, e *capitan.Event) {
        if !strings.HasPrefix(e.Signal().Name(), "tendo.op.") {
            return
        }

        attrs := []slog.Attr{
            slog.String("signal", e.Signal().Name()),
            slog.Time("timestamp", e.Timestamp()),
        }

        if output, ok := tendo.KeyOutput.From(e); ok {
            attrs = append(attrs,
                slog.Any("output_shape", output.Shape()),
                slog.String("output_device", output.Device().String()),
            )
        }

        logger.LogAttrs(ctx, slog.LevelDebug, "tensor_op", attrs...)
    })
}
```

### Prometheus Metrics

```go
import "github.com/prometheus/client_golang/prometheus"

var (
    opsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "tendo_ops_total",
            Help: "Total tensor operations",
        },
        []string{"operation"},
    )

    memoryAllocated = prometheus.NewCounter(
        prometheus.CounterOpts{
            Name: "tendo_memory_allocated_bytes_total",
            Help: "Total bytes allocated",
        },
    )
)

func init() {
    prometheus.MustRegister(opsTotal, memoryAllocated)
}

func setupMetrics() {
    capitan.Observe(func(ctx context.Context, e *capitan.Event) {
        name := e.Signal().Name()

        if strings.HasPrefix(name, "tendo.op.") {
            opsTotal.WithLabelValues(name).Inc()
        }
    })

    capitan.Hook(tendo.PoolAlloc, func(ctx context.Context, e *capitan.Event) {
        bytes, _ := tendo.KeyBytes.From(e)
        memoryAllocated.Add(float64(bytes))
    })
}
```

### Device Transfer Alerts

```go
func alertOnTransfers() {
    capitan.Hook(tendo.TensorTransfer, func(ctx context.Context, e *capitan.Event) {
        from, _ := tendo.KeyFromDevice.From(e)
        to, _ := tendo.KeyToDevice.From(e)

        // Alert on GPU->CPU transfers (potential bottleneck)
        if from.IsCUDA() && to.IsCPU() {
            log.Printf("WARNING: GPU->CPU transfer detected")
        }
    })
}
```

## Scoped Observation

### Per-Request Tracing

```go
func handleRequest(ctx context.Context, input *tendo.Tensor) *tendo.Tensor {
    // Create scoped observer
    var ops []string
    observer := capitan.Observe(func(ctx context.Context, e *capitan.Event) {
        if strings.HasPrefix(e.Signal().Name(), "tendo.op.") {
            ops = append(ops, e.Signal().Name())
        }
    })
    defer observer.Close()

    // Process request
    output := model.Forward(input)

    // Log operations for this request
    log.Printf("Request operations: %v", ops)

    return output
}
```

### Conditional Observation

```go
func debugMode(enabled bool) {
    if !enabled {
        return
    }

    capitan.Observe(func(ctx context.Context, e *capitan.Event) {
        // Verbose logging only in debug mode
        fmt.Printf("[DEBUG] %s: %v\n",
            e.Signal().Name(),
            e.Fields())
    })
}
```
