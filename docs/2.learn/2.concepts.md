---
title: Core Concepts
description: Tensors, storage, devices, and shapes - the building blocks of tendo
author: zoobzio
published: 2025-12-16
updated: 2025-12-16
tags:
  - Concepts
  - Tensors
  - Storage
  - Shapes
---

# Core Concepts

Tendo has five core primitives: tensors, storage, devices, dtypes, and shapes. Understanding these unlocks the full API.

## Tensors

A tensor is a multi-dimensional array with metadata:

```go
type Tensor struct {
    storage Storage
    shape   []int
    stride  []int
    offset  int
}
```

Create tensors with constructors:

```go
// From data
t := tendo.FromSlice([]float32{1, 2, 3, 4}, 2, 2)

// Filled
zeros := tendo.Zeros(3, 4)
ones := tendo.Ones(2, 2)

// Random
rand := tendo.RandN(10, 10)
```

### Tensor Properties

```go
t.Shape()        // []int - dimensions
t.Stride()       // []int - memory stride
t.Dim()          // int - number of dimensions
t.Size(dim)      // int - size of specific dimension
t.Numel()        // int - total elements
t.Device()       // Device - where data lives
t.DType()        // DType - element type
t.IsContiguous() // bool - optimal memory layout
```

### Views vs Copies

Many operations return views (shared storage) rather than copies:

```go
ctx := context.Background()

t := tendo.Arange(0, 12, 1)
reshaped, _ := tendo.Reshape(3, 4).Run(ctx, t)  // View: same storage, different shape

// Check contiguity
reshaped.IsContiguous() // true for simple reshapes

// Force a copy
copy := t.Clone()

// Make contiguous if needed
cont := t.Contiguous()
```

Views share the underlying storage. Modifying one affects the other. Use `Clone()` when you need independent data.

## Storage

Storage abstracts memory allocation across devices:

```go
type Storage interface {
    Ptr() uintptr      // Raw pointer
    Size() int         // Bytes allocated
    Len() int          // Element count
    Device() Device    // Location
    DType() DType      // Data type
    Clone() Storage    // Deep copy
    Free()             // Release memory
}
```

### CPUStorage

CPU storage wraps a Go slice:

```go
// Internal structure
type CPUStorage struct {
    data  []float32
    dtype DType
}
```

CPU storage is managed by Go's garbage collector. `Free()` sets the slice to nil.

### CUDAStorage

CUDA storage holds a device pointer:

```go
// Internal structure
type CUDAStorage struct {
    ptr    uintptr
    size   int
    len    int
    device int
    dtype  DType
    pool   *Pool
}
```

CUDA storage must be explicitly freed or managed via a Pool. The `Free()` method returns memory to the pool or calls `cudaFree`.

## Devices

Devices represent compute locations:

```go
type Device struct {
    Type  DeviceType  // CPU or CUDA
    Index int         // GPU index (0 for CPU)
}
```

### Device Constructors

```go
cpu := tendo.CPUDevice()      // CPU device
gpu := tendo.CUDADevice(0)    // First GPU
gpu1 := tendo.CUDADevice(1)   // Second GPU
```

### Default Device

```go
// Get current default
device := tendo.DefaultDevice()

// Set default for new tensors
tendo.SetDefaultDevice(tendo.CUDADevice(0))

// Create on default device
t := tendo.Zeros(100, 100)  // Now on GPU
```

### Device Checking

```go
device := t.Device()

device.IsCPU()   // true if CPU
device.IsCUDA()  // true if GPU
device.String()  // "cpu" or "cuda:0"
```

### CUDA Availability

```go
if tendo.IsCUDAAvailable() {
    tendo.SetDefaultDevice(tendo.CUDADevice(0))
}
```

## Data Types

DType specifies element precision:

```go
const (
    Float32  DType = iota  // 32-bit float (default)
    Float16                // 16-bit IEEE 754 half
    BFloat16               // 16-bit brain float
)
```

### DType Properties

```go
dtype := tendo.Float32

dtype.String()  // "float32"
dtype.Size()    // 4 (bytes per element)
```

### Default DType

```go
// Get current default
dtype := tendo.DefaultDType()

// Set default (affects new tensors)
tendo.SetDefaultDType(tendo.Float16)
```

### DType Conversion

```go
ctx := context.Background()

// Convert tensor dtype
f16, _ := tendo.ToFloat16().Run(ctx, t)
f32, _ := tendo.ToFloat32().Run(ctx, t)
bf16, _ := tendo.ToBFloat16().Run(ctx, t)

// Or use aliases
half, _ := tendo.Half().Run(ctx, t)
```

See [Data Types Guide](../3.guides/3.dtypes.md) for precision tradeoffs.

## Shapes and Strides

Shape defines tensor dimensions. Stride defines memory layout.

### Shape

```go
t := tendo.Zeros(2, 3, 4)
t.Shape()  // [2, 3, 4]
t.Dim()    // 3
t.Numel()  // 24
```

### Stride

Stride indicates how many elements to skip for each dimension:

```go
t := tendo.Zeros(2, 3, 4)
t.Stride()  // [12, 4, 1] for row-major (C-order)
```

For a contiguous row-major tensor:
- Last dimension stride is 1
- Each dimension stride = product of subsequent dimension sizes

### Non-Contiguous Tensors

Some operations create non-contiguous tensors:

```go
ctx := context.Background()

t := tendo.Zeros(3, 4)
transposed, _ := tendo.Transpose(0, 1).Run(ctx, t)

transposed.Shape()        // [4, 3]
transposed.Stride()       // [1, 4] - not contiguous!
transposed.IsContiguous() // false
```

Non-contiguous tensors share storage with the original but access elements differently. Many operations require contiguous input:

```go
// Make contiguous before operations that require it
cont := transposed.Contiguous()  // Creates a copy with optimal layout
```

### Shape Operations

```go
ctx := context.Background()

// Reshape (view if possible)
reshaped, _ := tendo.Reshape(6, 4).Run(ctx, t)

// Squeeze: remove size-1 dimensions
squeezed, _ := tendo.Squeeze(0).Run(ctx, t)

// Unsqueeze: add size-1 dimension
expanded, _ := tendo.Unsqueeze(0).Run(ctx, t)

// Transpose specific dimensions
transposed, _ := tendo.Transpose(0, 1).Run(ctx, t)

// Permute all dimensions
permuted, _ := tendo.Permute(2, 0, 1).Run(ctx, t)
```

## Broadcasting

Binary operations support NumPy-style broadcasting:

```go
ctx := context.Background()

a := tendo.Zeros(3, 4)
b := tendo.Zeros(4)      // Broadcasts to [3, 4]

c, _ := tendo.Add(b).Run(ctx, a)  // Shape: [3, 4]
```

### Broadcasting Rules

1. Shapes are compared from the right
2. Dimensions match if equal or one is 1
3. Missing dimensions are treated as 1

```go
// Examples
[3, 4] + [4]    -> [3, 4]  // b broadcasts
[3, 4] + [3, 1] -> [3, 4]  // b broadcasts
[3, 4] + [1, 4] -> [3, 4]  // a broadcasts dim 0
[3, 4] + [2, 4] -> error   // 3 != 2, neither is 1
```

## Error Types

Tendo uses typed errors for specific failure modes:

### ShapeError

```go
type ShapeError struct {
    Op      string
    ShapeA  []int
    ShapeB  []int
    Message string
}
```

Raised for incompatible shapes in operations.

### DeviceError

```go
type DeviceError struct {
    Expected DeviceType
    Got      DeviceType
}
```

Raised when an operation doesn't support the tensor's device.

### DeviceMismatchError

```go
type DeviceMismatchError struct {
    A Device
    B Device
}
```

Raised when binary operations receive tensors on different devices.

### Error Checking

```go
import "errors"

result, err := operation.Run(ctx, t)
if err != nil {
    var shapeErr *tendo.ShapeError
    if errors.As(err, &shapeErr) {
        // Handle shape error
    }
}
```
